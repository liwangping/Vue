<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <title>Vue</title>
</head>
<body>
    <div id="app">
        <!-- <p>{{foo}}</p> -->
        <!-- 这里的'foo'不会更新 -->
        <!-- <button v-on:click = "foo = 'baz'">change it</button> -->
        <!-- <div id="example">
            <p>Original message: "{{message}}"</p>
            <p>Computed reversed message: "{{reversedMessage}}"</p>
        </div> -->
    </div>
    <!-- <p>Reversed message: "{{ reversedMessage() }}"</p> -->
    <div id="demo">{{ fullName }}</div>
    <!-- <script>
        var data = { a: 1}

        // 该对象被加入到一个 Vue 实例中
        // var vm = new Vue({
        //     data: data
        // })   
        //你只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)
        //获得这个实例上的属性
        //返回源数据中对应的字段
       
        // vm.a == data.a // => true

        // // 设置属性也会影响到原始数据
        // vm.a = 2
        // data.a // => 2

        // // ……反之亦然
        // data.a = 3
        // vm.a // => 3

        //冻结这里的obj,阻止修改现有的属性，也意味着响应系统无法再追踪变化。
        var obj = {
            foo: 'bar'
        }
        Object.freeze(obj)

        new Vue({
            el:'#app',
            data:obj
        })

        new Vue({
            data:{
                a: 1
            },
            //生命周期钩子的函数
            //实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。
            created: function () {
                // 'this'指向vm实例
                console.log('a is:' + this.a)
            },
            // 不要在选项属性或回调上使用箭头函数，比如 created: () => console.log(this.a) 或 
            // vm.$watch('a', newValue => this.myMethod())。因为箭头函数并没有 this，this 
            // 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 
            // 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。
        })

        // var vm = new Vue({
        // el: '#example',
        // data: {
        //     message: 'Hello'
        // },
        // methods: {
        // reversedMessage: function () {
        //     return this.message.split('').reverse().join('')
        // }
        // },
        // computed: {
        //     // 计算属性的 getter
        //     reversedMessage: function () {
        //     // `this` 指向 vm 实例
        //     return this.message.split('').reverse().join('')
        //     }
        // }
        // })
    //    var vm = new Vue({
    //        el: '#demo',
    //        data: {
    //            firstName: 'Foo',
    //            lastName: 'Bar',
    //            fullName: 'Foo Bar'
    //        },
    //        watch: {
    //            firstName: function(val){
    //                this.fullName = val + ' ' + this.lastName
    //            },
    //            lastName: function (val){
    //                this.fullName = this.firstName + ' ' + val
    //            }
    //        }
    //    })
        //下面的计算属性方法对比上面的watch事件更为简单和清晰
    var vm = new Vue({
        el:'#demo',
        data: {
            firstName: 'Foo',
            lastName: 'Bar'
        },
        computed: {
            //getter
            fullName: {
                get: function(){
                    return this.firstName + ' ' + this.lastName
                },
                //setter
                //计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：
                //setter方法可以通过改变fullName来改变firstName和last
                set: function(newValue) {
                    var names = newValue.split(' ')
                    this.firstName = names[0]
                    this.lastName = names[names.length - 1]
                }
            }            
        },
    }) -->
    //虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么
    // Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据
    //变化时执行异步或开销较大的操作时，这个方式是最有用的。

    </script>
    
</body>
</html>